# 阅读提示
1. 内容拆解
    * 重构原则 - 介绍何为、为何、何时、如何重构
    * 重构示例 - 以一个示例引出代码坏味道及消除方式
    * 代码的坏味道 - 介绍24种代码坏味道及消除方式(重构手法)
    * 重构手法 - 详细介绍所有重构手法    
3. 阅读与运用   
    * 阅读并**熟悉**代码的坏味道
    * 概略浏览并**了解**重构列表
    * 在自己项目中**识别**代码的坏味道
    * 在本书**坏味道及重构手法速查表**中查阅坏味道的重构手法  
    * 在本书**重构列表**中查阅重构手法的具体运用方式  
    * **消除**项目中的代码坏味道 
2. 分享内容  
    * 介绍重构原则  
    * 由一个示例引出代码坏味道及消除方式  
    * 介绍所有代码坏味道及消除方式
# 重构的原则
## 何为重构
1. 定义  
在不改变软件可观察行为的前提下改善其内部结构，提高其可理解性，降低其修改成本。
2. 关键  
大量微小且保持软件原有行为的步骤是重构的关键。  
如果有人说他们的代码在重构过程中有一两天时间不可用，基本上可以确定，他们在做的事情不是重构。
> 重构是在做其他事情过程中(阅读代码、修复bug、迭代功能)自然而然发生的。重构过程的关键在于不改变原有行为。我们偶尔会有跨版本大规模重构，这可能是不可取的。
## 为何重构
1. 重构改进软件设计  
如果没有重构，程序的内部设计会逐渐腐败变质。  
经常性的重构有助于代码维持自己该有的样子。
2. 重构使软件更容易理解   
任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀的程序员。  
好代码的检验标准就是人们是否能轻而易举地修改它。
3. 重构帮助你理解代码  
对代码的理解，可以帮助你找到bug。
4. 重构提高编程速度  
总而言之，良好的设计是快速开发的根本，重构可以提高设计质量，帮我更快速的开发程序。  
理想情况下，我的代码仓库会逐步演化成一个平台，在其上可以很容易地构造与其领域相关的新功能。
## 何时重构
1. 何时重构  
    * 预备性重构 - 让添加新功能更容易
    * 帮助理解的重构 - 使代码更易懂
    * 捡垃圾式重构 - 让营地比你到达时更干净
    * 审核代码时重构 - 重构可以帮助代码复审工作得到更具体的结果
2. 有计划的重构和见机行事的重构  
重构不是与编程割裂的行为。  
有计划的、专门安排一段时间的重构应该很少。  
大部分重构应该是不起眼的、见机行事的、在做其他事情过程中自然发生的。
3. 何时不应该重构  
    * 凌乱的代码如果不需要修改，那么就不需要重构
    * 如果重写比重构更容易，就别重构了
## 如何重构
1. 好的测试是重构的前提
重构前，先检查自己是否有一套可靠的测试机制。这些测试必须有自我检验能力。
2. 重构的节奏：测试、小修改、测试、小修改…
每次修改的幅度都很小，所以任何错误都很容易发现。
3. 添加新功能与重构过程应该交替进行，而不是同时进行。
## 重构与性能
1. 为了让软件更易于理解，我们常会做一些使程序运行更慢的修改(重构)；为了让软件运行更快，我们往往会做一些使代码较难理解的修改(性能优化)。
2. 虽然重构有时使软件运行更慢，但它也使软件的性能优化更容易。
3. 重构时你不必担心性能，优化时你才需要担心他们。
4. 程序运行时大部分时间一般都耗费在一小半代码上，不必要一视同仁地优化所有代码。
5. 你应该使用一个度量工具来监控程序的运行，让它告诉你程序汇总哪些地方大量消耗时间和空间。
# 重构示例
## 示例介绍
1. 戏剧演出团费用规则
    * 悲剧  
    基础费用40000。如果观众超过30人，则超出部分每人1000。
    * 喜剧  
    基础费用30000。每人额外300。如果超出20人, 则基础费用多加10000且超出部分每人多加500。
2. 喜剧演出团积分规则
    * 悲剧  
    超出30人部分，每人1个积分。
    * 喜剧  
    每满5人1个积分。超出30人部分，每人1个积分。
## 

# 代码的坏味道
如果尿布臭了，就换掉它。
## 一. 神秘命名（Mysterious Name）
1. 整洁代码最重要的一环就是好的名字。
2. 改名可能是最常用的重构手法，包括改变*函数声明（124）*、*变量改名（137）*、*字段改名（244）*等。
3. 如果你想不出一个好名字，说明背后很可能潜藏着更深的设计问题。
## 二. 重复代码（Duplicated Code）
1. 如果你在一个以上的地点看到相同的程序结构，设法将他们合而为一，程序会变得更好。
2. 同一个类的两个函数含有相同的表达式，采用 *提炼函数（106）* 提炼出重复的代码。
3. 如果重复代码只是相似而不是完全相同，首先尝试使用 *移动语句（223）* 重组代码顺序，把相似的部分放在一起以便提炼。
4. 如果重复的代码段位于同一个超类的不同子类中，可以使用 *函数上移（350）* 来避免两个子类之间互相调用。
## 三. 过长函数（Long Function）
1. 绝大部分情况下，要把函数变小，只需要使用 *提炼函数（106）* 。
2. 如果函数中有个别参数和临时变量，可以把他们当做参数，传递给被提炼出来的新函数。
3. 如果被提炼函数内有大量的参数和临时变量，可以运用 *以查询取代临时变量（178）* 来消除这些临时元素。
4. 使用 *引入参数对象（140）* 和 *保持对象完整（319）* 可以将过长的参数列变得更简洁一些。
5. 如果被提炼函数仍然有太多临时变量和参数，可以使用以 *命令取代函数（337）* 。
6. 注释通常能够指出应该被提炼的代码。就算只有一行代码，如果它需要以注释来说明，那也值得将它提炼到独立函数去。 
7. 你可以使用 *分解条件表达式（260）* 处理条件表达式。对于庞大的switch语句，每个分支都应该通过 *提炼函数(106)* 变成独立的函数调用。如果有多个switch语句语句基于同一个条件进行分支选择，就应该使用以 *多态取代条件表达式（272）* 。
8. 你应该将循环和其内的代码提炼到一个独立的函数中。如果循环中做了几件不同的事情，请勇敢的使用拆分循环（227）将其拆分成各自独立的任务。
> 拆分循环是第2版才有的重构手法，对于简化循环可以起到至关重要的作用。副作用也很明显，可能导致循环多次执行。不必担心代码会运行的更慢，先让代码更容易理解和修改，然后再使用性能分析工具针对性的进行优化。
## 四. 过长参数列表（Long Parameter List）
1. 如果可以向某个参数发起查询而获得另一个参数，那么就可以使用 *以查询取代参数（324）* 去掉这第二个参数。
2. 如果你发现自己正在从现有的数据结构中抽出很多数据项，就可以考虑使用 *保持对象完整（319）* 手法，直接传入原来的数据结构。
3. 如果有几项参数总是同时出现，可以用 *引入参数对象（140）* 将其合并成一个对象。
4. 如果某个参数被用作区分函数行为的标记（flag），可以使用 *移除标记参数（314）*。
5. 如果多个函数有同样的几个参数，引入一个类就尤为有意义。你可以使用 *函数组合成类（144）* ，将这些共同的参数变成这个类的字段。
## 五. 全局数据（Global Data）
1. 全局数据的问题在于，从代码库的任何一个角落都可以修改它，而且没有任何机制可以探测出到底哪段代码做出了修改。
2. 全局数据最显而易见的形式就是全局变量，但类变量和单例（singleton）也有这样的问题。
3. 首要的防御手段是 *封装变量（132）*，把全局数据用一个函数包装起来，至少你就能看见修改它的地方，并开始控制对它的访问。
4. 随后，最好将这个函数及其封装的数据搬移到一个类或模块中，只允许模块内的代码使用它，从而尽量控制其作用域。
## 六. 可变数据（Mutable Data）
1. 用 *封装变量（132）* 来确保所有数据更新操作都通过很少几个函数来进行，使其更容易监控和演进。
2. 如果一个变量在不同时候被用于存储不同的东西， 可以使用 *拆分变量（240）* 将其拆分为各自不同用途的变量，从而避免危险的更 新操作。
3. 使用 *移动语句（223）* 和 *提炼函数（106）* 尽量把逻辑从处理更新操作的代码中搬移出来，将没有副作用的代码与执行数据更新操作的代码分开。
4. 使用 *将查询函数和修改函数分离（306）* 确保调用者不会调到有副作用的代码，除非他们真的需要更新数据。
5. 我们还乐于尽早使用 *移除设值函数（331）* ——有时只是把设值函数的使用者找出来看看，就能帮我们发现缩小变量作用域的机会。
6. 如果可变数据的值能在其他地方计算出来，这就是一个特别刺鼻的坏味道。 使用 *以查询取代派生变量（248）* 即可解决。
7. 可以用 *函数组合成类（144）* 或者 *函数组合成变换（149）* 来限制需要对变量进行修改的代码量。
8. 如果一个变量在 其内部结构中包含了数据，通常最好不要直接修改其中的数据，而是用 *将引用对 象改为值对象（252）* 令其直接替换整个数据结构。
## 七. 发散式变化（Divergent Change）
1. 我们希望软件能够更容易被修改。一旦需要修改，我们希望能够**跳到系统的某一点，只在该处做修改**。
2. 如果某个类经常因为不同的原因在不同的方向上发生变化， 发散式变化就出现了。
3. 如果发生变化的两个方向自然地形成了先后次序（比如说，先从数据库取出数据，再对其进行金融逻辑处理），就可以用 *拆分阶段（154）* 将两者分开，两者之间通过一个清晰的数据结构进行沟通。
4. 如果两个方向之间有更多的来回调用，就应该先创建适当的模块，然后用 *搬移函数（198）* 把处理逻辑分开。
5. 如果函数内部混合了两类处理逻辑，应该先用 *提炼函数（106）* 将其分开，然后再做搬移。
6. 如果模块是以类的形式定义的，就可以用 *提炼类（182）* 来做拆分。
## 八. 霰弹式修改（Shotgun Surgery）
1. 如果每遇到某种变化，你都 必须在许多不同的类内做出许多小修改，你所面临的坏味道就是霰弹式修改。
2. 如果需要修改的代码散布四处，你应该使用搬移函数（198）和搬移字段（207）把所有需要修 改的代码放进同一个模块里。
3. 如果有很多函数都在操作相似的数据，可以使用函 数组合成类（144）。
4. 如果有些函数的功能是转化或者充实数据结构，可以使用 函数组合成变换（149）。
5. 如果一些函数的输出可以组合后提供给一段专门使用 这些计算结果的逻辑，这种时候常常用得上拆分阶段（154）。
6. 面对霰弹式修改，一个常用的策略就是使用与内联（inline）相关的重构—— 如内联函数（115）或是内联类（186）——把本不该分散的逻辑拽回一处。
## 九. 依恋情结（Feature Envy）
1. 所谓模块化，就是力求将代码分出区域，最大化区域内部的交互、最小化跨区域的交互。一个函数跟另一个模块中的函数或者数据交流格外频繁，远胜于在自己所处模块内部的交流，这就是依恋情结的典型情况。
2. 这个函数想跟这些数据待在一起，那就使用搬移函数（198）把它移过去。
3. 函数中只有一部分受这种依恋之苦，应该使用提炼函数（106）把这一部分提炼到独立的函数中，再使用搬移函数（198）带它去它的梦想家园。
4. 如果一个函数用到几个类的功能，那么需要判断哪个类拥有最多被此函数使用的数据，然后就把这个函数和那些数据摆在一起。
## 十. 数据泥团（Data Clumps）
1. 数据项就像小孩子，喜欢成群结队地待在一块儿。这些总是绑在一起出现的数据真应该拥有属于它们自己的对象。
2. 运用提炼类（182）将它们提炼到一个独立对象中。然后将注意力转移到函数签名上，运用引入参数对象（140）或保持对象完整（319）为它瘦身。
3. 如果删掉众多数据中的一项，其他数据不再有意义，那么他们应该以一个对象的形式存在。
4. 一旦拥有新对象，你就有机会让程序散发出一种芬芳。可以将适当的程序行为移至新类。
## 十一. 基本类型偏执（Primitive Obsession）
1. 大多数编程环境都大量使用基本类型，即整数、浮点数和字符串等。一些库会引入一些小对象，如日期。很多程序员不愿意 创建对自己的问题域有用的基本对象，如钱、坐标、范围等。字符串是这种坏味道的最佳培养皿。
2. 运用以对象取代基本类型（174）将原本单独存在的数据值替换为对象。
3. 如果想要替换的数据值是控制条件行为的类型码，则可以运用以子类取代类型码（362）加上以多态取代 条件表达式（272）的组合将它换掉。 
4. 如果你有一组总是同时出现的基本类型数据，这就是数据泥团的征兆，应该 运用提炼类（182）和引入参数对象（140）来处理。
## 十二. 重复的switch （Repeated Switches）
1. 重复的switch的问题在于：每当你想增加一个选择分支时，必须找到所有 的switch，并逐一更新。
2. 多态给了我们对抗这种黑暗力量的武器，使我们得到更优雅的代码库。
## 十三. 循环语句（Loops）
1. 从最早的编程语言开始，循环就一直是程序设计的核心要素。但我们感觉如 今循环已经有点儿过时，就像喇叭裤和植绒壁纸那样。
2. 我们可以使用以管道取代循环（231）来让这些老古董退休。管道操作（如filter和map）可以帮助我们更快地看清被处理的元素以及处理它们的动作。
## 十四. 冗赘的元素（Lazy Element）
1. 如果一个函数，它的名字就跟实现代码看起来一模一样；也可能有这样一个类，根本就是一个简单的函数。
2. 通常你只需要使用内联函数 （115）或是内联类（186）。
3. 如果这个类处于一个继承体系中，可以使用折叠继承体系（380）。
## 十五. 夸夸其谈通用性（Speculative Generality）
1. 当有人说“噢，我想我们总有一天需要做这事”，并企图以各式各样的钩子和特殊情况来处理一些非必要的事情，这种坏味道就出现了。
2. 如果所有装置都会被用到，那就值得那么做；如果用不到，就不值得。用不上的装置只会挡你的路，所以，把它搬开吧。
3. 如果你的某个抽象类其实没有太大作用，请运用折叠继承体系（380）。
4. 不必要的委托可运用内联函数（115）和内联类（186）除掉。
5. 如果函数的某些参数未被用上，可以用改变函数声明（124）去掉这些参数。
6. 如果有并非真正需要、只是为不知远在何处的将来而塞进去的参数，也应该用改变函数声明（124）去掉。
## 十六. 临时字段（Temporary Field）
1. 有时你会看到这样的类：其内部某个字段仅为某种特定情况而设。这样的代 码让人不易理解，因为你通常认为对象在所有时候都需要它的所有字段。
2. 请使用提炼类（182）给这个可怜的孤儿创造一个家，然后用搬移函数 （198）把所有和这些字段相关的代码都放进这个新家。
3. 也许你还可以使用引入特例（289）在“变量不合法”的情况下创建一个替代对象，从而避免写出条件式代码。
## 十七. 过长的消息链（Message Chains）
1. 如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象……这就是消息链。
2. 这时候应该使用隐藏委托关系（189）。
3. 先观察消息链最终得到的对象是用 来干什么的，看看能否以提炼函数（106）把使用该对象的代码提炼到一个独立 的函数中，再运用搬移函数（198）把这个函数推入消息链。
## 十八. 中间人（Middle Man）
1. 对象的基本特征之一就是封装——对外部世界隐藏其内部细节。封装往往伴随着委托。
2. 人们可能过度运用委托。你也许会看到某个类的接口有一半的函数都委托给其他类，这样就是过度运用。
3. 这时应该使用移除中间人（192），直接和真正负责的对象打交道。
4. 如果这样“不干实事”的函数只有少数几个，可以运用内联函数（115）把它们放进调用端。
5. 如果这些中间人还有其他行为，可以运用以委托取代超类（399）或者以委托取代子类（381）把它变成真正的对象，这样你既可以扩展原对象的行为，又不必负担那么多的委托动作。
## 十九. 内幕交易（Insider Trading）
1. 软件开发者喜欢在模块之间建起高墙，极其反感在模块之间大量交换数据， 因为这会增加模块间的耦合。在实际情况里，一定的数据交换不可避免，但我们必须尽量减少这种情况，并把这种交换都放到明面上来。
2. 如果两个模块总是在咖啡机旁边窃窃私语，就应该用搬移函数（198）和搬移字段（207）减少它们的私下交流。
3. 如果两个模块有共同的兴趣，可以尝试再新建一个模块，把这些共用的数据放在一个管理良好的地方；或者用隐藏委托关 系（189），把另一个模块变成两者的中介。
4. 继承常会造成密谋，因为子类对超类的了解总是超过后者的主观愿望。如果你觉得该让这个孩子独立生活了，请运用以委托取代子类（381）或以委托取代 超类（399）让它离开继承体系。
## 二十. 过大的类（Large Class）
1. 如果想利用单个类做太多事情，其内往往就会出现太多实例变量。一旦如此，重复代码也就接踵而至了。
2. 你可以运用提炼类（182）将几个彼此相关的变量一起提炼至新类内。如果这个组件适合作为一个子类，你会发现提炼超类（375）或者以子类取代类型码（362）（其实就是提炼子类）往往比较简单。
3. 和“太多实例变量”一样，类内如果有太多代码，也是代码重复、混乱并最终走向死亡的源头。
4. 如果有五个“百行函数”，他们之中有很多代码相同，那么你也许可以把他们变成五个“十行函数”和十个提炼出的“双行函数”。
5. 看看大类的使用者是否只用到了这个类所有功能的一个子集，每个这样的子集都可能拆分成一个独立的类。一旦识别出一个合适的功能子集，就试用提炼类（182）、提炼超类（375） 或是以子类取代类型码（362）将其拆分出来。
## 二十一. 异曲同工的类（Alternative Classes with Different Interfaces）
1. 如果两个函数做同一件事，却有着不同的签名，请运用改变函数声明 （124）将函数签名变得一致。
2. 请反复运用搬移函数（198）将某些行为移入类中，直到两者的协议一致为止。如果搬移过程造成了重复代码， 或许可运用提炼超类（375）补偿一下。
## 二十二. 纯数据类（Data Class）
1. 所谓纯数据类是指：它们拥有一些字段，以及用于访问（读写）这些字段的 函数，除此之外一无长物。这样的类只是一种不会说话的数据容器，它们几乎一 定被其他类过分细琐地操控着。
2. 纯数据类常常意味着行为被放在了错误的地方。也就是说，只要把处理数据的行为从客户端搬移到纯数据类里来，就能使情况大为改观。
3. 这些类早期可能拥有public字段，你应该运用封装记录（162）将它们封装起来。对于那些不该被其他类修改的字段，请运用移除设值函数（331）。
4. 找出这些取值/设值函数被其他类调用的地点。尝试以搬移函数 （198）把那些调用行为搬移到纯数据类里来。如果无法搬移整个函数，就运用 提炼函数（106）产生一个可被搬移的函数。
5. 例外情况就是，纯数据记录对象被用作函数调用的返回结果。这种结果数据对象有一个关键的特征：它是不可修改的。不可修改的字段无须封装，使用者可以直接通过字段取得数据，无须通过取值函数。
## 二十三. 被拒绝的遗赠（Refused Bequest）
1. 子类应该继承超类的函数和数据。但如果它们不想或不需要继承，又该怎么 办呢？它们得到所有礼物，却只从中挑选几样来玩！
2. 按传统说法，这就意味着继承体系设计错误。你需要为这个子类新建一个兄 弟类，再运用函数下移（359）和字段下移（361）把所有用不到的函数下推给那 个兄弟。这样一来，超类就只持有所有子类共享的东西。
3. 我们不建议你这么做。既然不愿意支持超类的接口，就不要虚情假意地糊弄继承体系，应该运用以委托取代子类（381）或者以 委托取代超类（399）彻底划清界限。
## 二十四. 注释（Comments）
1. 注释本身不是一种坏味道，事实上他们还是一种香味呢。
2. 有时候，注释之所以存在乃是因为代码很糟糕。把注释当做除臭剂是一种坏味道。
3. 很多时候，注释可以帮助我们找到代码的坏味道。找到坏味道之后，我们首先应该以各种重构手法把坏味道去除。完成之后我们常常会发现：注释已经变得多余了，因为代码已经清晰说明了这一切。
4. 如果你需要注释来解释一块代码做了什么，试试提炼函数（106）；如果函数已经提炼出来，但还是需要注释来解释其行为，试试用改变函数声明（124） 为它改名；如果你需要注释说明某些系统的需求规格，试试引入断言（302）。
5. 当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余。
6. 注释应该用来记述将来的打算、标记你并无十足把握的区域。你可以在注释里写下自己“为什么做某某事”。这类信息可以帮助将来的修改者，尤其是那些健忘的家伙。